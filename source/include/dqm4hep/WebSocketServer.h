/// \file WebSocketServer.h
/*
 *
 * WebSocketServer.h header template automatically generated by a class generator
 * Creation date : sam. dï¿½c. 3 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#ifndef SERVER_H
#define SERVER_H

// -- dqm4hep headers
#include <dqm4hep/Internal.h>
#include <dqm4hep/Signal.h>

#include <functional>
#include <websocketpp/config/asio_no_tls.hpp>
#include <websocketpp/server.hpp>

namespace dqm4hep {

  namespace net {
    
    typedef websocketpp::server<websocketpp::config::asio> server;
    typedef websocketpp::connection_hdl connection_hdl;
    typedef std::set<server::connection_ptr> connection_set;
    typedef std::map<std::string, connection_set> connection_map;
    typedef server::message_ptr message_ptr;
    typedef server::connection_type::message_type message_type;
    typedef message_ptr WsMessage;
    typedef server::connection_ptr WsConnection;
            
    class WsServer;
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    enum ServiceType {
      UNKNOWN_TYPE = 0,
      SERVICE_TYPE = 1,
      COMMAND_TYPE = 2,
      RPC_TYPE = 3
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    class WsServiceBase {
      WsServiceBase(const WsServiceBase &) = delete;
      WsServiceBase &operator=(const WsServiceBase&) = delete;
    public:
      WsServiceBase(WsServer *s, const std::string &n, ServiceType t);
      virtual ~WsServiceBase();
        
      WsServer* server() const;      
      const std::string &name() const;
      ServiceType type() const;
        
    private:
      WsServer*              m_server = {nullptr};
      std::string            m_name = {""};
      ServiceType            m_type = {UNKNOWN_TYPE};
    };
    
    typedef std::map<std::string, WsServiceBase*> ServiceMap;
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    class WsService : public WsServiceBase {
    public:
      WsService(WsServer *s, const std::string &n);
      template <typename T>
      void send(const T &value);
      void send(const char *buffer, size_t size, bool containsBinary = false);
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    class WsCommandHandler : public WsServiceBase {
    public:
      typedef core::Signal<WsConnection, WsMessage> signal_type;
      WsCommandHandler(WsServer *s, const std::string &n);
      signal_type &onCommand();
    private:
      signal_type            m_signal = {};
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    class WsRequestHandler : public WsServiceBase {
    public:
      typedef core::Signal<WsConnection, WsMessage, WsMessage&> signal_type;
      WsRequestHandler(WsServer *s, const std::string &n);
      signal_type &onRequest();
    private:
      signal_type            m_signal = {};
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /**
     * WsServer class
     */
    class WsServer {
      WsServer(const WsServer&) = delete;
      WsServer& operator=(const WsServer&) = delete;
      friend class WsService;
    public:
      WsServer();
      ~WsServer();
      
      void setPort(int port);
      WsService *createService(const std::string &name);
      WsCommandHandler *createCommandHandler(const std::string &name);
      WsRequestHandler *createRequestHandler(const std::string &name);
      WsService *findService(const std::string &name);
      WsCommandHandler *findCommandHandler(const std::string &name);
      WsRequestHandler *findRequestHandler(const std::string &name);
      void start();
      void stop();
      
    private:
      void onOpen(connection_hdl hdl);
      void onClose(connection_hdl hdl);
      void onMessage(connection_hdl hdl, message_ptr msg);
      void send(WsService *service, const char *buffer, size_t size, bool containsBinary);
      void onServiceMessage(const std::string &serviceName, connection_hdl hdl, message_ptr msg);
      void onCommandMessage(const std::string &serviceName, connection_hdl hdl, message_ptr msg);
      void onRpcMessage(const std::string &serviceName, connection_hdl hdl, message_ptr msg);

    private:
      connection_map             m_serviceConnections = {};
      server                     m_server;
      int                        m_port = {5555};
      bool                       m_blocking = {false};
      std::thread                m_thread = {};
      ServiceMap                 m_serviceMap = {};
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline void WsService::send(const T &value) {
      std::string valueStr = dqm4hep::core::typeToString(value);
      send(valueStr.c_str(), valueStr.size(), false);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <>
    inline void WsService::send(const std::string &value) {
      send(value.c_str(), value.size(), false);
    }

  }
  
}

#endif //  SERVER_H
